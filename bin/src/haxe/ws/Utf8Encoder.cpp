// Generated by Haxe 4.3.1
#include <hxcpp.h>

#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_Encoding
#include <haxe/io/Encoding.h>
#endif
#ifndef INCLUDED_haxe_ws_Utf8Encoder
#include <haxe/ws/Utf8Encoder.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_aaee8cd2b1816670_8_encode,"haxe.ws.Utf8Encoder","encode",0x4dfc0ea3,"haxe.ws.Utf8Encoder.encode","haxe/ws/Utf8Encoder.hx",8,0x52117bbd)
HX_LOCAL_STACK_FRAME(_hx_pos_aaee8cd2b1816670_13_decode,"haxe.ws.Utf8Encoder","decode",0xb90579bb,"haxe.ws.Utf8Encoder.decode","haxe/ws/Utf8Encoder.hx",13,0x52117bbd)
namespace haxe{
namespace ws{

void Utf8Encoder_obj::__construct() { }

Dynamic Utf8Encoder_obj::__CreateEmpty() { return new Utf8Encoder_obj; }

void *Utf8Encoder_obj::_hx_vtable = 0;

Dynamic Utf8Encoder_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Utf8Encoder_obj > _hx_result = new Utf8Encoder_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Utf8Encoder_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x4838bb89;
}

 ::haxe::io::Bytes Utf8Encoder_obj::encode(::String str){
            	HX_STACKFRAME(&_hx_pos_aaee8cd2b1816670_8_encode)
HXDLIN(   8)		return ::haxe::io::Bytes_obj::ofString(str,null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Utf8Encoder_obj,encode,return )

::String Utf8Encoder_obj::decode( ::haxe::io::Bytes data){
            	HX_STACKFRAME(&_hx_pos_aaee8cd2b1816670_13_decode)
HXDLIN(  13)		return data->toString();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Utf8Encoder_obj,decode,return )


Utf8Encoder_obj::Utf8Encoder_obj()
{
}

bool Utf8Encoder_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"encode") ) { outValue = encode_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"decode") ) { outValue = decode_dyn(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *Utf8Encoder_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo *Utf8Encoder_obj_sStaticStorageInfo = 0;
#endif

::hx::Class Utf8Encoder_obj::__mClass;

static ::String Utf8Encoder_obj_sStaticFields[] = {
	HX_("encode",16,f2,e3,f9),
	HX_("decode",2e,5d,ed,64),
	::String(null())
};

void Utf8Encoder_obj::__register()
{
	Utf8Encoder_obj _hx_dummy;
	Utf8Encoder_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("haxe.ws.Utf8Encoder",41,b4,d0,5c);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Utf8Encoder_obj::__GetStatic;
	__mClass->mSetStaticField = &::hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Utf8Encoder_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< Utf8Encoder_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Utf8Encoder_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Utf8Encoder_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace ws
